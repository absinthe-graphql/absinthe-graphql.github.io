<!DOCTYPE HTML>
<html class="no-js" lang="en">

  <head>
  <meta charset="utf-8">
  <title>Absinthe: Ecto Best Practices</title>
  <link rel="stylesheet" href="/css/main.css">

  <!-- ok >

  <!-- you don't need to keep this, but it's cool for stats! -->
  <meta name="generator" content="Nanoc 4.1.4">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">


  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/img/favicon.ico">

  <script src="/js/main.js"></script>
</head>


<body class="preload markdown-body collection">

  <header id="page-header" role="banner">
  <a href="/"><h1 class="logo">Absinthe</h1></a>
  <a id="mobile-menu" class="js-mobile-nav">Navigation Menu</a>
<nav id="main-navigation">
  <ol>
    <li><a href='/learning-graphql/'>GraphQL?</a></li>
    <li><a href='/tutorial/'>Tutorial</a></li>
    <li><a href='/guides/' class="active">Guides</a></li>
    <li><a href='/community/'>Community</a></li>
    <li><a href='/projects/'>Projects</a></li>
    <li>
      <a class="icon-link" target="github" href="https://github.com/absinthe-graphql">
        <svg aria-hidden="true" height="28" role="img" version="1.1" viewBox="0 0 16 16" width="28"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59 0.4 0.07 0.55-0.17 0.55-0.38 0-0.19-0.01-0.82-0.01-1.49-2.01 0.37-2.53-0.49-2.69-0.94-0.09-0.23-0.48-0.94-0.82-1.13-0.28-0.15-0.68-0.52-0.01-0.53 0.63-0.01 1.08 0.58 1.23 0.82 0.72 1.21 1.87 0.87 2.33 0.66 0.07-0.52 0.28-0.87 0.51-1.07-1.78-0.2-3.64-0.89-3.64-3.95 0-0.87 0.31-1.59 0.82-2.15-0.08-0.2-0.36-1.02 0.08-2.12 0 0 0.67-0.21 2.2 0.82 0.64-0.18 1.32-0.27 2-0.27 0.68 0 1.36 0.09 2 0.27 1.53-1.04 2.2-0.82 2.2-0.82 0.44 1.1 0.16 1.92 0.08 2.12 0.51 0.56 0.82 1.27 0.82 2.15 0 3.07-1.87 3.75-3.65 3.95 0.29 0.25 0.54 0.73 0.54 1.48 0 1.07-0.01 1.93-0.01 2.2 0 0.21 0.15 0.46 0.55 0.38C13.71 14.53 16 11.53 16 8 16 3.58 12.42 0 8 0z"></path></svg>
      </a>
    </li>
  </ol>
</nav>

</header>


  <main id="main">
    <nav id="page-navigation">
  <p class="page-navigation-header">guides</p>
  <ol>
    
      <li class="with-after"><a href='/guides/'>Guide Index</a></li>
    
      <li class="with-after"><a href='/guides/writing-schemas/'>Writing Schemas</a></li>
    
      <li class="with-after"><a href='/guides/plug-phoenix/'>Plug and Phoenix</a></li>
    
      <li class="with-after"><a href='/guides/context-and-authentication/'>Context and Authentication</a></li>
    
      <li class="with-after"><a href='/guides/custom-scalars/'>Custom Scalars</a></li>
    
      <li class="with-after"><a href='/guides/introspection/'>Introspection</a></li>
    
      <li class="with-after"><a href='/guides/deprecation/'>Deprecation</a></li>
    
      <li class="with-after"><a href='/guides/variables/'>Variables</a></li>
    
      <li class="with-after"><a href='/guides/adapters/'>Adapters</a></li>
    
      <li class="with-after"><a href='/guides/ecto-best-practices/' class="active">Ecto Best Practices</a></li>
    
      <li class="with-after"><a href='/guides/relay/'>Relay</a></li>
    
  </ol>
</nav>


    <article>
      <header>
        <h1>Ecto Best Practices</h1>
      </header>
      
<p>This guide is going to grow as we develop more tooling around Ecto integrations
(it’s a priority on <a href="/roadmap">our roadmap</a>, but there are some important things
we can point out now that might be helpful.</p>

<h2 id="avoiding-n1-queries">Avoiding N+1 Queries</h2>

<p>In general, you want to make sure that when accessing Ecto associations that you
preload the data in the top level resolver functions to avoid N+1 queries.</p>

<p>Imagine this scenario: You have posts and users. A Post has an author field, which
returns a user. You want to list all posts, and get the name of their author</p>

<figure class="codeblock"><pre><code class="language-graphql highlight"><span class="err">{</span>
  <span class="n">posts</span> <span class="err">{</span>
    <span class="n">author</span> <span class="err">{</span>
      <span class="n">name</span>
    <span class="err">}</span>
  <span class="err">}</span>
<span class="err">}</span></code></pre>
<figcaption class="description">A deceptively simple query.</figcaption>
</figure>

<p>If you write your schema like this, you’re going to have a <em>bad</em> time:</p>

<figure class="codeblock"><pre><code class="language-elixir highlight"><span class="n">object</span> <span class="ss">:post</span> <span class="k">do</span>
  <span class="nv">@desc</span> <span class="sd">"</span><span class="s2">Author of the post"</span>
  <span class="n">field</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">:user</span> <span class="k">do</span>
    <span class="n">resolve</span> <span class="k">fn</span> <span class="n">post</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">-&gt;</span>
      <span class="n">author</span> <span class="o">=</span>
        <span class="n">post</span>
        <span class="o">|&gt;</span> <span class="no">Ecto</span><span class="o">.</span><span class="n">assoc</span><span class="p">(</span><span class="ss">:author</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">one</span>

      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">author</span><span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">query</span> <span class="k">do</span>
  <span class="n">field</span> <span class="ss">:posts</span><span class="p">,</span> <span class="n">list_of</span><span class="p">(</span><span class="ss">:post</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">resolve</span> <span class="k">fn</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">-&gt;</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="no">Post</span> <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">all</span><span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<figcaption class="description">A naive approach, subject to N+1 issues.</figcaption>
</figure>

<p>What this schema will do when presented with the GraphQL query is
run <code>Category |&gt; Repo.all</code>, which will retrieve <em>N</em> categories. Then for each
<em>N</em> category it will resolve child fields, which runs our <code>Repo.one</code> query
function, resulting in <em>N+1</em> calls to the database.</p>

<p>Instead, use batching! At the moment (Oct-31-2016) Batching is pretty new, so we
don’t yet have some of the helper functions we want to in order to make this easier.</p>

<p>Fortunately the batching API is pretty simple. The idea with batching is that we’re
gonna aggregate all the <code>author_id</code>s from each post, and then make one call to the user.</p>

<p>Let’s first make a function to get a model by ids.</p>

<figure class="codeblock"><pre><code class="language-elixir highlight"><span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Schema</span><span class="o">.</span><span class="no">Helpers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">by_id</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">ids</span><span class="p">)</span> <span class="k">do</span>
    <span class="kn">import</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Query</span>
    <span class="n">model</span>
    <span class="o">|&gt;</span> <span class="n">where</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="n">m</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="o">^</span><span class="n">ids</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">all</span>
    <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="p">{</span><span class="nv">&amp;1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nv">&amp;1</span><span class="p">})</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>Now we can use this function to batch our author lookups:</p>

<figure class="codeblock"><pre><code class="language-elixir highlight"><span class="n">object</span> <span class="ss">:post</span> <span class="k">do</span>
  <span class="nv">@desc</span> <span class="sd">"</span><span class="s2">Author of the post"</span>
  <span class="n">field</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">:user</span> <span class="k">do</span>
    <span class="n">resolve</span> <span class="k">fn</span> <span class="n">post</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">-&gt;</span>
      <span class="n">batch</span><span class="p">({</span><span class="no">MyApp</span><span class="o">.</span><span class="no">Schema</span><span class="o">.</span><span class="no">Helpers</span><span class="p">,</span> <span class="ss">:by_id</span><span class="p">,</span> <span class="no">User</span><span class="p">},</span> <span class="n">post</span><span class="o">.</span><span class="n">author_id</span><span class="p">,</span> <span class="k">fn</span> <span class="n">batch_results</span> <span class="o">-&gt;</span>
        <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="no">Map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">batch_results</span><span class="p">,</span> <span class="n">post</span><span class="o">.</span><span class="n">author_id</span><span class="p">)}</span>
      <span class="k">end</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
<figcaption class="description">Batch loading users.</figcaption>
</figure>

<p>Now we make just two calls to the database. The first call loads all of the posts.
Then as Absinthe walks through each post and tries to get the author, it’s instead
told to aggregate its information.</p>

<p>That aggregate information is passed on to our <code>by_id/2</code> function from earlier.
It grabs ALL the users in just one database call, and creates a map of user ids
to users.</p>

<p>Absinthe then does a second pass and calls the <code>batch_results</code> function with that
map, letting us retrieve the individual author for each post.</p>

<p>Not only is this a very efficient way to query the data, it’s also 100% dynamic.
If a query document asks for authors, they’re loaded efficiently. If it does not,
they aren’t loaded at all.</p>

<p>See FIXME link</p>

<h2 id="the-future">The Future</h2>

<p>The <code>batch</code> API above is a bit verbose. This verbosity happens because it’s very
generic, so you gotta give it the individual bits and pieces. However for Ecto
associations specifically, you can easily see how the code we have above could be
made more succinct by using information we already have on our Ecto schemas.</p>

<p>Thus what we hope to have soon in Absinthe.Ecto (doesn’t exist yet) are functions
that let you do something like:</p>

<figure class="codeblock"><pre><code class="language-elixir highlight"><span class="n">object</span> <span class="ss">:post</span> <span class="k">do</span>
  <span class="n">field</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="n">field</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">:user</span><span class="p">,</span> <span class="ss">resolve:</span> <span class="n">belongs_to</span><span class="p">(</span><span class="no">User</span><span class="p">,</span> <span class="ss">:author</span><span class="p">)</span>
  <span class="n">field</span> <span class="ss">:comments</span><span class="p">,</span> <span class="n">list_of</span><span class="p">(</span><span class="ss">:comment</span><span class="p">),</span> <span class="ss">resolve:</span> <span class="n">has_many</span><span class="p">(</span><span class="no">Comment</span><span class="p">)</span>
<span class="k">end</span></code></pre>
</figure>

<p>This <code>belongs_to</code> function would derive the right batching approach based on the
Ecto association. These functions are mere conveniences. Everything they would do
functionally is available to you today!</p>

    </article>

  </main>

  <footer id="page-footer">
  <p>Please report any issues & contribute changes to the <a href="https://github.com/absinthe-graphql/website" target="github-website">website repository</a>. Thanks!</p>
  <p>Background image <a href="https://www.flickr.com/photos/anitacanita/4635683623">"green"</a> by Ana C., license available <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">here</a>.</p>
</footer>


</body>
</html>
